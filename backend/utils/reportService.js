import PDFDocument from 'pdfkit';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { query } from './database.js';
import emailService from './emailService.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const reportsDir = path.join(__dirname, '../reports');

// Ensure reports directory exists
if (!fs.existsSync(reportsDir)) {
  fs.mkdirSync(reportsDir, { recursive: true });
}

/**
 * Generate PDF report with device summary
 */
export const generateDeviceSummaryReport = async (deviceId, startDate, endDate) => {
  try {
    const doc = new PDFDocument({ margin: 50 });
    const filename = `device-summary-${deviceId}-${Date.now()}.pdf`;
    const filepath = path.join(reportsDir, filename);
    const stream = fs.createWriteStream(filepath);

    doc.pipe(stream);

    // Header
    doc.fontSize(24).font('Helvetica-Bold').text('PELBIOT Device Summary Report', { align: 'center' });
    doc.fontSize(10).font('Helvetica').text(`Generated: ${new Date().toLocaleString()}`, { align: 'center' });
    doc.moveDown(0.5);

    // Device Information
    const devices = await query('SELECT * FROM devices WHERE id = ?', [deviceId]);
    if (!devices.length) {
      throw new Error('Device not found');
    }
    const device = devices[0];

    doc.fontSize(12).font('Helvetica-Bold').text('Device Information');
    doc.fontSize(10).font('Helvetica');
    doc.text(`Device ID: ${device.id}`);
    doc.text(`Device Name: ${device.name}`);
    doc.text(`Type: ${device.type}`);
    doc.text(`Location: ${device.location || 'N/A'}`);
    doc.text(`IP Address: ${device.ip_address || 'N/A'}`);
    doc.text(`Status: ${device.status}`);
    doc.moveDown(0.5);

    // Period
    doc.fontSize(12).font('Helvetica-Bold').text('Report Period');
    doc.fontSize(10).font('Helvetica');
    doc.text(`Start Date: ${new Date(startDate).toLocaleDateString()}`);
    doc.text(`End Date: ${new Date(endDate).toLocaleDateString()}`);
    doc.moveDown(0.5);

    // Panel Data
    doc.fontSize(12).font('Helvetica-Bold').text('Panel Data Summary');
    const panels = await query('SELECT * FROM panels WHERE device_id = ? ORDER BY panel_number', [deviceId]);
    
    if (panels.length > 0) {
      doc.fontSize(9).font('Helvetica');
      doc.text('Panel #\tVoltage\tAmpere\tPower\tStatus');
      doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
      
      panels.forEach((panel) => {
        const powerValue = panel.power ? panel.power.toFixed(2) : 'N/A';
        doc.text(`${panel.panel_number}\t${panel.voltage}\tV\t${panel.ampere}\tA\t${powerValue}\tW\t${panel.status}`);
      });
    }
    doc.moveDown(0.5);

    // Trend Summary
    doc.fontSize(12).font('Helvetica-Bold').text('Power Trends');
    const trends = await query(
      'SELECT DATE(created_at) as trend_date, AVG(power) as avg_power, MAX(power) as max_power, MIN(power) as min_power ' +
      'FROM trends WHERE device_id = ? AND DATE(created_at) BETWEEN ? AND ? GROUP BY DATE(created_at)',
      [deviceId, startDate, endDate]
    );

    if (trends.length > 0) {
      doc.fontSize(9).font('Helvetica');
      doc.text('Date\t\tAvg Power\tMax Power\tMin Power');
      doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
      
      trends.forEach((trend) => {
        const date = new Date(trend.trend_date).toLocaleDateString();
        const avgPower = trend.avg_power ? trend.avg_power.toFixed(2) : '0';
        const maxPower = trend.max_power ? trend.max_power.toFixed(2) : '0';
        const minPower = trend.min_power ? trend.min_power.toFixed(2) : '0';
        doc.text(`${date}\t${avgPower}W\t${maxPower}W\t${minPower}W`);
      });
    }
    doc.moveDown(0.5);

    // Alert Summary
    doc.fontSize(12).font('Helvetica-Bold').text('Alert Summary');
    const alerts = await query(
      'SELECT severity, COUNT(*) as count FROM alerts WHERE device_id = ? AND DATE(created_at) BETWEEN ? AND ? GROUP BY severity',
      [deviceId, startDate, endDate]
    );

    if (alerts.length > 0) {
      doc.fontSize(9).font('Helvetica');
      alerts.forEach((alert) => {
        doc.text(`${alert.severity.charAt(0).toUpperCase() + alert.severity.slice(1)}: ${alert.count} alerts`);
      });
    }

    doc.moveDown(1);
    doc.fontSize(8).font('Helvetica').text('Report generated by PELBIOT Energy Management System', { align: 'center' });

    doc.end();

    return new Promise((resolve, reject) => {
      stream.on('finish', () => {
        resolve({ filename, filepath });
      });
      stream.on('error', reject);
    });
  } catch (error) {
    console.error('Error generating device summary report:', error.message);
    throw error;
  }
};

/**
 * Generate PDF report with trend analysis
 */
export const generateTrendAnalysisReport = async (deviceId, startDate, endDate, metric = 'power') => {
  try {
    const doc = new PDFDocument({ margin: 50 });
    const filename = `trend-analysis-${deviceId}-${Date.now()}.pdf`;
    const filepath = path.join(reportsDir, filename);
    const stream = fs.createWriteStream(filepath);

    doc.pipe(stream);

    // Header
    doc.fontSize(24).font('Helvetica-Bold').text('PELBIOT Trend Analysis Report', { align: 'center' });
    doc.fontSize(10).font('Helvetica').text(`Generated: ${new Date().toLocaleString()}`, { align: 'center' });
    doc.moveDown(0.5);

    // Device Information
    const devices = await query('SELECT * FROM devices WHERE id = ?', [deviceId]);
    if (!devices.length) {
      throw new Error('Device not found');
    }
    const device = devices[0];

    doc.fontSize(12).font('Helvetica-Bold').text('Device Information');
    doc.fontSize(10).font('Helvetica');
    doc.text(`Device: ${device.name}`);
    doc.text(`Type: ${device.type}`);
    doc.text(`Location: ${device.location || 'N/A'}`);
    doc.moveDown(0.5);

    // Analysis Parameters
    doc.fontSize(12).font('Helvetica-Bold').text('Analysis Parameters');
    doc.fontSize(10).font('Helvetica');
    doc.text(`Metric: ${metric.toUpperCase()}`);
    doc.text(`Period: ${new Date(startDate).toLocaleDateString()} to ${new Date(endDate).toLocaleDateString()}`);
    doc.moveDown(0.5);

    // Trend Data
    doc.fontSize(12).font('Helvetica-Bold').text(`${metric.charAt(0).toUpperCase() + metric.slice(1)} Trends`);
    const trends = await query(
      `SELECT DATE(created_at) as trend_date, AVG(${metric}) as avg_value, MAX(${metric}) as max_value, MIN(${metric}) as min_value 
       FROM trends WHERE device_id = ? AND DATE(created_at) BETWEEN ? AND ? GROUP BY DATE(created_at) ORDER BY trend_date`,
      [deviceId, startDate, endDate]
    );

    if (trends.length > 0) {
      doc.fontSize(9).font('Helvetica');
      const metricUnitMap = { power: 'W', energy: 'Wh', temperature: 'Â°C', load: '%' };
      const unit = metricUnitMap[metric] || '';
      doc.text(`Date\t\tAverage\t\tMax\t\tMin`);
      doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
      
      trends.forEach((trend) => {
        const date = new Date(trend.trend_date).toLocaleDateString();
        const avg = trend.avg_value ? trend.avg_value.toFixed(2) : '0';
        const max = trend.max_value ? trend.max_value.toFixed(2) : '0';
        const min = trend.min_value ? trend.min_value.toFixed(2) : '0';
        doc.text(`${date}\t${avg}${unit}\t${max}${unit}\t${min}${unit}`);
      });

      // Summary Statistics
      doc.moveDown(0.5);
      doc.fontSize(12).font('Helvetica-Bold').text('Summary Statistics');
      const stats = trends.reduce((acc, t) => ({
        avg: acc.avg + parseFloat(t.avg_value || 0),
        max: Math.max(acc.max, parseFloat(t.max_value || 0)),
        min: Math.min(acc.min, parseFloat(t.min_value || Infinity))
      }), { avg: 0, max: 0, min: Infinity });

      doc.fontSize(10).font('Helvetica');
      doc.text(`Overall Average: ${(stats.avg / trends.length).toFixed(2)}${unit}`);
      doc.text(`Peak Value: ${stats.max.toFixed(2)}${unit}`);
      doc.text(`Minimum Value: ${stats.min.toFixed(2)}${unit}`);
    }

    doc.moveDown(1);
    doc.fontSize(8).font('Helvetica').text('Report generated by PELBIOT Energy Management System', { align: 'center' });

    doc.end();

    return new Promise((resolve, reject) => {
      stream.on('finish', () => {
        resolve({ filename, filepath });
      });
      stream.on('error', reject);
    });
  } catch (error) {
    console.error('Error generating trend analysis report:', error.message);
    throw error;
  }
};

/**
 * Generate PDF report with alert history
 */
export const generateAlertHistoryReport = async (deviceId, startDate, endDate) => {
  try {
    const doc = new PDFDocument({ margin: 50 });
    const filename = `alert-history-${deviceId}-${Date.now()}.pdf`;
    const filepath = path.join(reportsDir, filename);
    const stream = fs.createWriteStream(filepath);

    doc.pipe(stream);

    // Header
    doc.fontSize(24).font('Helvetica-Bold').text('PELBIOT Alert History Report', { align: 'center' });
    doc.fontSize(10).font('Helvetica').text(`Generated: ${new Date().toLocaleString()}`, { align: 'center' });
    doc.moveDown(0.5);

    // Device Information
    const devices = await query('SELECT * FROM devices WHERE id = ?', [deviceId]);
    if (!devices.length) {
      throw new Error('Device not found');
    }
    const device = devices[0];

    doc.fontSize(12).font('Helvetica-Bold').text('Device Information');
    doc.fontSize(10).font('Helvetica');
    doc.text(`Device: ${device.name}`);
    doc.text(`Type: ${device.type}`);
    doc.text(`Location: ${device.location || 'N/A'}`);
    doc.moveDown(0.5);

    // Analysis Period
    doc.fontSize(12).font('Helvetica-Bold').text('Analysis Period');
    doc.fontSize(10).font('Helvetica');
    doc.text(`From: ${new Date(startDate).toLocaleDateString()}`);
    doc.text(`To: ${new Date(endDate).toLocaleDateString()}`);
    doc.moveDown(0.5);

    // Alerts
    doc.fontSize(12).font('Helvetica-Bold').text('Alerts in Period');
    const alerts = await query(
      'SELECT * FROM alerts WHERE device_id = ? AND DATE(created_at) BETWEEN ? AND ? ORDER BY created_at DESC',
      [deviceId, startDate, endDate]
    );

    if (alerts.length > 0) {
      doc.fontSize(9).font('Helvetica');
      doc.text('Time\t\t\tSeverity\tStatus\t\tMessage');
      doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
      
      alerts.forEach((alert) => {
        const time = new Date(alert.created_at).toLocaleString();
        const severity = alert.severity.toUpperCase();
        const status = alert.status.toUpperCase();
        const message = alert.message ? alert.message.substring(0, 40) : 'N/A';
        doc.fontSize(8);
        doc.text(`${time}\t${severity}\t${status}\t${message}`);
      });

      // Alert Summary
      doc.moveDown(0.5);
      doc.fontSize(12).font('Helvetica-Bold').text('Alert Summary');
      const summary = alerts.reduce((acc, a) => {
        acc[a.severity] = (acc[a.severity] || 0) + 1;
        return acc;
      }, {});

      doc.fontSize(10).font('Helvetica');
      Object.entries(summary).forEach(([severity, count]) => {
        doc.text(`${severity.charAt(0).toUpperCase() + severity.slice(1)}: ${count}`);
      });
    } else {
      doc.fontSize(10).font('Helvetica').text('No alerts found in the specified period.');
    }

    doc.moveDown(1);
    doc.fontSize(8).font('Helvetica').text('Report generated by PELBIOT Energy Management System', { align: 'center' });

    doc.end();

    return new Promise((resolve, reject) => {
      stream.on('finish', () => {
        resolve({ filename, filepath });
      });
      stream.on('error', reject);
    });
  } catch (error) {
    console.error('Error generating alert history report:', error.message);
    throw error;
  }
};

/**
 * Generate PDF report with energy consumption analysis
 */
export const generateEnergyReport = async (deviceId, startDate, endDate) => {
  try {
    const doc = new PDFDocument({ margin: 50 });
    const filename = `energy-report-${deviceId}-${Date.now()}.pdf`;
    const filepath = path.join(reportsDir, filename);
    const stream = fs.createWriteStream(filepath);

    doc.pipe(stream);

    // Header
    doc.fontSize(24).font('Helvetica-Bold').text('PELBIOT Energy Consumption Report', { align: 'center' });
    doc.fontSize(10).font('Helvetica').text(`Generated: ${new Date().toLocaleString()}`, { align: 'center' });
    doc.moveDown(0.5);

    // Device Information
    const devices = await query('SELECT * FROM devices WHERE id = ?', [deviceId]);
    if (!devices.length) {
      throw new Error('Device not found');
    }
    const device = devices[0];

    doc.fontSize(12).font('Helvetica-Bold').text('Device Information');
    doc.fontSize(10).font('Helvetica');
    doc.text(`Device: ${device.name}`);
    doc.text(`Type: ${device.type}`);
    doc.text(`Location: ${device.location || 'N/A'}`);
    doc.moveDown(0.5);

    // Analysis Period
    doc.fontSize(12).font('Helvetica-Bold').text('Analysis Period');
    doc.fontSize(10).font('Helvetica');
    doc.text(`From: ${new Date(startDate).toLocaleDateString()}`);
    doc.text(`To: ${new Date(endDate).toLocaleDateString()}`);
    doc.moveDown(0.5);

    // Energy Data
    doc.fontSize(12).font('Helvetica-Bold').text('Daily Energy Consumption');
    const energyData = await query(
      `SELECT DATE(created_at) as energy_date, SUM(energy) as total_energy, AVG(power) as avg_power, MAX(power) as peak_power 
       FROM trends WHERE device_id = ? AND DATE(created_at) BETWEEN ? AND ? GROUP BY DATE(created_at) ORDER BY energy_date`,
      [deviceId, startDate, endDate]
    );

    if (energyData.length > 0) {
      doc.fontSize(9).font('Helvetica');
      doc.text('Date\t\tTotal Energy\tAvg Power\tPeak Power');
      doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
      
      let totalEnergy = 0;
      energyData.forEach((data) => {
        const date = new Date(data.energy_date).toLocaleDateString();
        const energy = data.total_energy ? data.total_energy.toFixed(2) : '0';
        const avgPower = data.avg_power ? data.avg_power.toFixed(2) : '0';
        const peakPower = data.peak_power ? data.peak_power.toFixed(2) : '0';
        totalEnergy += parseFloat(energy);
        doc.fontSize(8);
        doc.text(`${date}\t${energy} Wh\t${avgPower} W\t${peakPower} W`);
      });

      // Summary
      doc.moveDown(0.5);
      doc.fontSize(12).font('Helvetica-Bold').text('Period Summary');
      doc.fontSize(10).font('Helvetica');
      doc.text(`Total Energy Consumed: ${totalEnergy.toFixed(2)} Wh`);
      doc.text(`Average Daily Energy: ${(totalEnergy / energyData.length).toFixed(2)} Wh`);
      doc.text(`Report Duration: ${energyData.length} days`);
    } else {
      doc.fontSize(10).font('Helvetica').text('No energy data available for the specified period.');
    }

    doc.moveDown(1);
    doc.fontSize(8).font('Helvetica').text('Report generated by PELBIOT Energy Management System', { align: 'center' });

    doc.end();

    return new Promise((resolve, reject) => {
      stream.on('finish', () => {
        resolve({ filename, filepath });
      });
      stream.on('error', reject);
    });
  } catch (error) {
    console.error('Error generating energy report:', error.message);
    throw error;
  }
};

/**
 * Generate CSV report
 */
export const generateCSVReport = async (deviceId, startDate, endDate, reportType = 'summary') => {
  try {
    let csvContent = '';
    const filename = `report-${deviceId}-${Date.now()}.csv`;
    const filepath = path.join(reportsDir, filename);

    if (reportType === 'trends') {
      csvContent = 'Date,Average Power,Max Power,Min Power,Average Energy,Average Temperature,Average Load\n';
      const trends = await query(
        `SELECT DATE(created_at) as trend_date, AVG(power) as avg_power, MAX(power) as max_power, 
         MIN(power) as min_power, AVG(energy) as avg_energy, AVG(temperature) as avg_temp, AVG(load) as avg_load
         FROM trends WHERE device_id = ? AND DATE(created_at) BETWEEN ? AND ? GROUP BY DATE(created_at)`,
        [deviceId, startDate, endDate]
      );

      trends.forEach((trend) => {
        const row = [
          new Date(trend.trend_date).toLocaleDateString(),
          (trend.avg_power || 0).toFixed(2),
          (trend.max_power || 0).toFixed(2),
          (trend.min_power || 0).toFixed(2),
          (trend.avg_energy || 0).toFixed(2),
          (trend.avg_temp || 0).toFixed(2),
          (trend.avg_load || 0).toFixed(2)
        ];
        csvContent += row.join(',') + '\n';
      });
    } else if (reportType === 'alerts') {
      csvContent = 'Timestamp,Severity,Status,Message\n';
      const alerts = await query(
        'SELECT created_at, severity, status, message FROM alerts WHERE device_id = ? AND DATE(created_at) BETWEEN ? AND ?',
        [deviceId, startDate, endDate]
      );

      alerts.forEach((alert) => {
        const message = (alert.message || '').replace(/,/g, ';').replace(/"/g, '""');
        const row = [
          new Date(alert.created_at).toLocaleString(),
          alert.severity,
          alert.status,
          `"${message}"`
        ];
        csvContent += row.join(',') + '\n';
      });
    } else {
      csvContent = 'Date,Panel,Voltage,Ampere,Power,Status\n';
      const panels = await query(
        'SELECT p.panel_number, p.voltage, p.ampere, p.power, p.status, p.created_at FROM panels p WHERE p.device_id = ?',
        [deviceId]
      );

      panels.forEach((panel) => {
        const row = [
          new Date(panel.created_at).toLocaleDateString(),
          panel.panel_number,
          (panel.voltage || 0).toFixed(2),
          (panel.ampere || 0).toFixed(2),
          (panel.power || 0).toFixed(2),
          panel.status
        ];
        csvContent += row.join(',') + '\n';
      });
    }

    fs.writeFileSync(filepath, csvContent, 'utf8');
    return { filename, filepath };
  } catch (error) {
    console.error('Error generating CSV report:', error.message);
    throw error;
  }
};

/**
 * Send report via email
 */
export const sendReportByEmail = async (email, deviceId, reportType, startDate, endDate) => {
  try {
    let reportData;
    let reportFile;

    switch (reportType) {
      case 'device_summary':
        reportFile = await generateDeviceSummaryReport(deviceId, startDate, endDate);
        reportData = {
          reportName: 'Device Summary Report',
          deviceId,
          startDate,
          endDate
        };
        break;
      case 'trend_analysis':
        reportFile = await generateTrendAnalysisReport(deviceId, startDate, endDate);
        reportData = {
          reportName: 'Trend Analysis Report',
          deviceId,
          startDate,
          endDate
        };
        break;
      case 'alert_history':
        reportFile = await generateAlertHistoryReport(deviceId, startDate, endDate);
        reportData = {
          reportName: 'Alert History Report',
          deviceId,
          startDate,
          endDate
        };
        break;
      case 'energy':
        reportFile = await generateEnergyReport(deviceId, startDate, endDate);
        reportData = {
          reportName: 'Energy Consumption Report',
          deviceId,
          startDate,
          endDate
        };
        break;
      default:
        throw new Error('Unknown report type');
    }

    // Send via email
    const result = await emailService.sendReportEmail(email, reportData, reportFile.filepath);

    return {
      success: true,
      reportFile: reportFile.filename,
      messageId: result.messageId
    };
  } catch (error) {
    console.error('Error sending report by email:', error.message);
    throw error;
  }
};

/**
 * Get generated reports list
 */
export const getGeneratedReports = () => {
  try {
    if (!fs.existsSync(reportsDir)) {
      return [];
    }

    const files = fs.readdirSync(reportsDir);
    return files.map((file) => {
      const filepath = path.join(reportsDir, file);
      const stats = fs.statSync(filepath);
      return {
        filename: file,
        size: stats.size,
        created: stats.birthtimeMs,
        modified: stats.mtimeMs
      };
    });
  } catch (error) {
    console.error('Error getting reports list:', error.message);
    throw error;
  }
};

/**
 * Delete old reports (cleanup)
 */
export const deleteOldReports = (daysOld = 30) => {
  try {
    if (!fs.existsSync(reportsDir)) {
      return { deleted: 0 };
    }

    const files = fs.readdirSync(reportsDir);
    const now = Date.now();
    const cutoffTime = now - daysOld * 24 * 60 * 60 * 1000;
    let deleted = 0;

    files.forEach((file) => {
      const filepath = path.join(reportsDir, file);
      const stats = fs.statSync(filepath);
      if (stats.mtimeMs < cutoffTime) {
        fs.unlinkSync(filepath);
        deleted++;
      }
    });

    console.log(`ðŸ§¹ Cleanup: Deleted ${deleted} old reports (older than ${daysOld} days)`);
    return { deleted };
  } catch (error) {
    console.error('Error deleting old reports:', error.message);
    throw error;
  }
};

const reportService = {
  generateDeviceSummaryReport,
  generateTrendAnalysisReport,
  generateAlertHistoryReport,
  generateEnergyReport,
  generateCSVReport,
  sendReportByEmail,
  getGeneratedReports,
  deleteOldReports
};

export default reportService;
